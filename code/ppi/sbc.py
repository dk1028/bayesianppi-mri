# -*- coding: utf-8 -*-
"""sbc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i9iZ7HaqB7lFgRwxQrOrHriEeN9WcLer
"""

# sbc_cre_figs.py (notebook-friendly)
import os
import argparse
import numpy as np
import matplotlib.pyplot as plt

try:
    from scipy.stats import chisquare, kstest
    _HAVE_SCIPY = True
except Exception:
    _HAVE_SCIPY = False

def draw_beta_post(alpha: float, beta: float, size: int) -> np.ndarray:
    return np.random.beta(alpha, beta, size=size)

def plot_rank_hist_grouped_with_pvals(ranks, S, out_png, title, B=20):
    u = (ranks + 0.5) / (S + 1.0)
    bins = np.linspace(0.0, 1.0, B + 1)
    counts, _ = np.histogram(u, bins=bins)
    expected = np.full(B, len(u) / B)
    if _HAVE_SCIPY:
        chi2_stat, chi2_p = chisquare(counts, expected)
        ks_stat, ks_p = kstest(u, 'uniform')
    else:
        chi2_p = np.nan
        ks_p = np.nan
    plt.figure(figsize=(5.2, 3.4))
    xs = 0.5 * (bins[1:] + bins[:-1])
    width = 1.0 / B
    plt.bar(xs, counts, width=width * 0.9, align='center')
    plt.hlines(expected[0], 0, 1, linestyles='dashed', linewidth=1.2)
    plt.xlim(0, 1)
    plt.xlabel(r"Normalized rank  $u \in [0,1)$")
    plt.ylabel("Count per bin")
    plt.title(title)
    txt = (r"$\chi^2$ p={:.2f}; KS p={:.2f}").format(chi2_p, ks_p)
    plt.text(0.99, 0.97, txt, ha='right', va='top', transform=plt.gca().transAxes, fontsize=9)
    plt.tight_layout()
    plt.savefig(out_png, dpi=300)
    plt.close()

def run_sbc_cre(M=500, S=1000, NA=1000, NH=100, prior="jeffreys", seed=2025):
    rng = np.random.default_rng(seed)
    if prior.lower() == "jeffreys":
        aA = bA = a1 = b1 = a0 = b0 = 0.5
    else:
        aA = bA = a1 = b1 = a0 = b0 = 1.0
    ranks_thetaA  = np.empty(M, dtype=int)
    ranks_thetaH1 = np.empty(M, dtype=int)
    ranks_thetaH0 = np.empty(M, dtype=int)
    ranks_g       = np.empty(M, dtype=int)
    for m in range(M):
        thetaA_star  = rng.beta(aA, bA)
        thetaH1_star = rng.beta(a1, b1)
        thetaH0_star = rng.beta(a0, b0)
        g_star       = thetaA_star * thetaH1_star + (1.0 - thetaA_star) * thetaH0_star
        A_unlab = rng.binomial(1, thetaA_star, size=NA)
        A_lab   = rng.binomial(1, thetaA_star, size=NH)
        H_lab   = np.where(
            A_lab == 1,
            rng.binomial(1, thetaH1_star, size=NH),
            rng.binomial(1, thetaH0_star, size=NH)
        )
        nA  = A_unlab.sum()
        n11 = np.sum((A_lab == 1) & (H_lab == 1))
        n10 = np.sum((A_lab == 1) & (H_lab == 0))
        n01 = np.sum((A_lab == 0) & (H_lab == 1))
        n00 = np.sum((A_lab == 0) & (H_lab == 0))
        alphaA = aA + nA
        betaA  = bA + (NA - nA)
        alpha1 = a1 + n11
        beta1  = b1 + n10
        alpha0 = a0 + n01
        beta0  = b0 + n00
        thetaA_draws  = draw_beta_post(alphaA, betaA, S)
        thetaH1_draws = draw_beta_post(alpha1, beta1, S)
        thetaH0_draws = draw_beta_post(alpha0, beta0, S)
        g_draws = thetaA_draws * thetaH1_draws + (1.0 - thetaA_draws) * thetaH0_draws
        ranks_thetaA[m]  = np.sum(thetaA_draws  < thetaA_star)
        ranks_thetaH1[m] = np.sum(thetaH1_draws < thetaH1_star)
        ranks_thetaH0[m] = np.sum(thetaH0_draws < thetaH0_star)
        ranks_g[m]       = np.sum(g_draws       < g_star)
    return {"r_thetaA":ranks_thetaA,"r_thetaH1":ranks_thetaH1,"r_thetaH0":ranks_thetaH0,"r_g":ranks_g,"S":S,"M":M}

def run_and_save(prior="jeffreys", M=500, S=1000, NA=1000, NH=100, B=20, outdir="figs", seed=2025):
    os.makedirs(outdir, exist_ok=True)
    res = run_sbc_cre(M=M, S=S, NA=NA, NH=NH, prior=prior, seed=seed)
    suffix = f"{prior.lower()}_b{B}"
    fA  = os.path.join(outdir, f"sbc_thetaA_{suffix}.png")
    fH1 = os.path.join(outdir, f"sbc_thetaH1_{suffix}.png")
    fH0 = os.path.join(outdir, f"sbc_thetaH0_{suffix}.png")
    fG  = os.path.join(outdir, f"sbc_g_{suffix}.png")
    plot_rank_hist_grouped_with_pvals(res["r_thetaA"],  res["S"], fA,  r"SBC: $\theta_A$",        B=B)
    plot_rank_hist_grouped_with_pvals(res["r_thetaH1"], res["S"], fH1, r"SBC: $\theta_{H\mid1}$", B=B)
    plot_rank_hist_grouped_with_pvals(res["r_thetaH0"], res["S"], fH0, r"SBC: $\theta_{H\mid0}$", B=B)
    plot_rank_hist_grouped_with_pvals(res["r_g"],       res["S"], fG,  r"SBC: $g$",               B=B)
    return [fA, fH1, fH0, fG]

def parse_args(argv=None):
    p = argparse.ArgumentParser(description="SBC rank histograms for conjugate CRE.", add_help=True)
    p.add_argument("--prior", type=str, default="jeffreys", choices=["jeffreys", "uniform"])
    p.add_argument("--M", type=int, default=500)
    p.add_argument("--S", type=int, default=1000)
    p.add_argument("--NA", type=int, default=1000)
    p.add_argument("--NH", type=int, default=100)
    p.add_argument("--bins", type=int, default=20)
    p.add_argument("--outdir", type=str, default="figs")
    p.add_argument("--seed", type=int, default=2025)
    p.add_argument("--both", action="store_true")
    # NOTE: parse_known_args to ignore notebook-injected flags like "-f <path>"
    args, _unknown = p.parse_known_args(argv)
    return args

def main(argv=None):
    args = parse_args(argv)
    if args.both:
        files_u = run_and_save(prior="uniform", M=args.M, S=args.S, NA=args.NA, NH=args.NH, B=args.bins, outdir=args.outdir, seed=args.seed)
        files_j = run_and_save(prior="jeffreys", M=args.M, S=args.S, NA=args.NA, NH=args.NH, B=args.bins, outdir=args.outdir, seed=args.seed)
        print("Saved (uniform):", *files_u, sep="\n  ")
        print("Saved (jeffreys):", *files_j, sep="\n  ")
    else:
        files = run_and_save(prior=args.prior, M=args.M, S=args.S, NA=args.NA, NH=args.NH, B=args.bins, outdir=args.outdir, seed=args.seed)
        print("Saved:", *files, sep="\n  ")

if __name__ == "__main__":
    # When running inside notebooks, colab passes extra args; we already ignore them via parse_known_args.
    main()